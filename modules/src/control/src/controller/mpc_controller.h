/******************************************************************************
 * Copyright 2024 The EDrive Authors. All Rights Reserved.
 *****************************************************************************/

/**
 * @file
 * @brief Defines the MPCController class.
 */

#pragma once

#include <fstream>
#include <memory>
#include <string>

#include <eigen3/Eigen/Dense>

#include "control/src/controller/controller.h"
#include "control/src/common/trajectory_analyzer.h"
#include "control/src/controller/controller.h"

/**
 * @namespace EDrive::control
 * @brief EDrive::control
 */
namespace EDrive {
namespace control {

/**
 * @class MPCController
 *
 * @brief MPCController, combined lateral and logitudinal controllers
 */
class MPCController : public Controller {
 public:
  /**
   * @brief constructor
   */
  MPCController();

  /**
   * @brief destructor
   */
  virtual ~MPCController();

  /**
   * @brief initialize MPC Controller
   * @param control_conf control configurations
   * @return Status initialization status
   */
  common::Result_state Init(const ControlConf *control_conf) override;

  /**
   * @brief compute steering target and throttle/ brake based on current vehicle
   * status and target trajectory
   * @param localization vehicle location
   * @param chassis vehicle status e.g., speed, acceleration
   * @param trajectory trajectory generated by planning
   * @param cmd control command
   * @return Status computation status
   */
  common::Result_state ComputeControlCommand(
      const ::planning::ADCTrajectory *trajectory,
      const nav_msgs::Odometry *localization,
      ::control::CarlaEgoVehicleControl *control_command) override;

  /**
   * @brief reset MPC Controller
   * @return Status reset status
   */
  common::Result_state Reset() override;

  /**
   * @brief stop MPC controller
   */
  void Stop() override;

  /**
   * @brief MPC controller name
   * @return string controller name in string
   */
  std::string Name() const override;

 protected:
  void UpdateStateAnalyticalMatching(SimpleMPCDebug *debug);

  void UpdateMatrix(SimpleMPCDebug *debug);

  void FeedforwardUpdate(SimpleMPCDebug *debug);

  void ComputeLateralErrors(const double x, const double y, const double theta,
                            const double linear_v, const double angular_v,
                            const TrajectoryAnalyzer &trajectory_analyzer,
                            SimpleMPCDebug *debug);

  void ComputeLongitudinalErrors(const TrajectoryAnalyzer *trajectory,
                                 SimpleMPCDebug *debug);
  bool LoadControlConf(const ControlConf *control_conf);
  const std::string name_;

  // vehicle state matrix
  Eigen::MatrixXd matrix_a_;
  // vehicle state matrix (discrete-time)
  Eigen::MatrixXd matrix_ad_;

  // control matrix
  Eigen::MatrixXd matrix_b_;
  // control matrix (discrete-time)
  Eigen::MatrixXd matrix_bd_;

  // offset matrix
  Eigen::MatrixXd matrix_c_;
  // offset matrix (discrete-time)
  Eigen::MatrixXd matrix_cd_;

  // gain matrix
  Eigen::MatrixXd matrix_k_;
  // control authority weighting matrix
  Eigen::MatrixXd matrix_r_;
  // updated control authority weighting matrix
  Eigen::MatrixXd matrix_r_updated_;
  // state weighting matrix
  Eigen::MatrixXd matrix_q_;
  // updated state weighting matrix
  Eigen::MatrixXd matrix_q_updated_;
  // vehicle state matrix coefficients
  Eigen::MatrixXd matrix_a_coeff_;
  // 4 by 1 matrix; state matrix
  Eigen::MatrixXd matrix_state_;

  // heading error of last control cycle
  double previous_heading_error_ = 0.0;
  // lateral distance to reference trajectory of last control cycle
  double previous_lateral_error_ = 0.0;
};

}  // namespace control
}  // namespace EDrive